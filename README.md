JAMES (JUnit Model Extractor)
=============================

JAMES is a tool that aims at generating new tests for Web Services from existing JUnit tests. Currently it extracts a model in `.dot` format which can be rendered with the tool `dot` from Graphviz.

JAMES tool consists of two parts, a dynamic library (written in C++), and a server (written in Erlang). Both parts are designed to work in parallel. The dynamic library uses the JVMTI API to instrument the execution of JUnit Java tests and sends filtered trace information to the Erlang server. The Erlang server applies more complex filters and algorithms in order to generate the models.

## Compilation

Both parts of JAMES tool must be compiled independently.

### JVMTI Agent (Dynamic Library)

The source for the JVMTI Agent is located at the folder `agent`. It includes compilation scripts generated by autotools. They can be run by executing the following sequence of commands:

```bash
./autogen.sh
./configure
make
```

This should generate a file called libjames.so in a subdirectory called `.libs`. Note that the source of the agent depends on:

* __Boost libraries__ - Usually available as a dev package: libboost-dev
* __Java JRE__ - The same that is used for running the tests should be used. The `configure` script tries to locate the Java directory by itself by searching the path in which the program `javac` is located. In case that does not work, it will look for the environment variable `$JAVA_HOME`.

### Erlang Server

Source for the Erlang server is located in the folder `server`. It does not include any compilation scripts, but it can be easily compiled by executing:

```bash
erl -make
```

from the same folder. Or more conveniently:

```erl
make:all([load]).
```

from the Erlang interpreter.

## Usage

To extract a diagram from a set of JUnit tests, you must first initialise the Erlang Server, then run the JUnit tests using the JVMTI Agent, and then parse the traces that are stored in the server.

### JVMTI Agent (Dynamic Library)

The JVMTI Agent may be deployed by adding a parameter to the call to the Java JVM:

```bash
java -agentpath:/home/tux/Desktop/james/agent/.libs/libjames.so=4321
```
where 4321 is the port in which the Erlang Server is listening. Alternatively, it can be added to the environment variable `_JAVA_OPTIONS`, which is very convenient when the JUnit tests are being executed through a build automation tool like `ant` or `maven`:

```bash
export _JAVA_OPTIONS="-agentpath:/home/tux/Desktop/james/agent/.libs/libjames.so=4321"
```

### Erlang Server

The server itself can be controlled by the module `server`, which is implemented as a `gen_server`. Some of the commands it provides are:

* __`server:start()`__ - it starts the server and starts listening. It returns a tuple in the form `{ok, Pid, Port}` where Port is the port that the server is listening to, and Pid is the process identifier that the other commands require.

* __`server:stop(Pid)`__ - it stops the server and frees all the information stored.

* __`server:save_messages(Pid, FileNameAndPath)`__ - saves all the complete traces that are stored in the server to the file specified.

* __`server:load_messages(Pid, FileNameAndPath)`__ - loads information stored by `save_messages/2`.

* __`server:clear_messages(Pid)`__ - removes the information stored in the server, it may cause errors if JVMTI agents are still running.

Diagrams can be generated by using the module `parser_newstruct`, some available commands are:

* __`parser_newstruct:list_traces(Pid)`__ - fetches all the sets of traces in the server and returns a list of tuples in the form `{TracePos, TraceLength}`, where `TracePos` is the identifier and `TraceLength` is the length of a trace. Identifiers for each trace set are temporary and may change if new agents sent new traces to the server.
* __`parser_newstruct:gen_dia_to_files(Pid, TracePos, FilePathAndPrefix)`__ - generates a diagram for the specified set of traces and writes it in `.dot` format in files that start by `FilePathAndPrefix` and end with a number and the extension `.dot`.
* __`parser_newstruct:gen_dia_to_files(Pid, TracePos, FilePathAndPrefix, Config)`__ - it does the same than the three parameter version but allows the user to include a `#config{}` record with the fields described below. The three parameter version uses the default version of the record as defined in the header file: `records.hrl`


`#config{}` record has currently the following fields:

* __`remove_bubbles`__ - expects a boolean that specifies whether elliptic nodes should be removed from the diagram.
* __`highlight_loops`__ - specifies whether transitions that form a loop should be highlighted.
* __`collapse_integers`__ - when `true` alternative integers that form a sequence are joined in a node titled `integer_range`.
* __`collapse_strings`__ - when `true` it merges several consecutive invocations of `append` applied to constants into a single one.
* __`single_file`__ - specifies whether all the islands in the diagram should be included in the same file.
* __`num_of_islands`__ - sets a maximum limit for the num of islands that are included, if the number of island exceeds this limit, only the ones with a higher number of nodes are included. If the atom `inf` is provided, all the islands will be included.
* __`big_k_value`__ - value used for `K` in the K-tails-like algorithm used.
* __`small_k_value`__ - value used for `K` when trying to merge sequences that have the same root. It does not have effect if it is bigger than the `big_k_value`.
* __`remove_orphan_nodes`__ - specifies whether islands of a single node should be included in the diagram.
* __`discard_calls_beginning_with`__ - expects a list of strings, and any call to a method starting with one of the strings provided will be ignored by the algorithm, (as it had never happened). It may provoke unidentified objects.
* __`remove_nodes_up_from`__ - expects a list of strings, any node whose label matches a string in the list will be removed, and all of its dependencies will be removed too, (independently of whether they are dependencies of other nodes or not).


